{"script":"-- key limit intervalMS nowMS [amount]\nlocal key        = KEYS[1]\nlocal limit      = tonumber(ARGV[1])\nlocal intervalMS = tonumber(ARGV[2])\nlocal nowMS      = tonumber(ARGV[3])\nlocal amount     = math.max(tonumber(ARGV[4]), 0)\nlocal force      = ARGV[5] == \"true\"\n\nlocal timestampKey = key .. \":T\"\n\nlocal lastUpdateMS\nlocal prevTokens\n   \nlocal initialTokens = redis.call('GET',key)\nlocal initialUpdateMS = false\n\nif initialTokens == false then\n   -- If we found no record, we temporarily rewind the clock to refill\n   -- via addTokens below\n   prevTokens = 0\n   lastUpdateMS = nowMS - intervalMS\nelse\n   prevTokens = initialTokens\n   initialUpdateMS = redis.call('GET',timestampKey)\n   \n   if(initialUpdateMS == false) then -- this is a corruption\n      -- we make up a time that would fill this limit via addTokens below\n      lastUpdateMS = nowMS - ((prevTokens / limit) * intervalMS)\n   else\n      lastUpdateMS = initialUpdateMS\n   end\nend\n\n-- tokens that should have been added by now\nlocal addTokens = ((nowMS - lastUpdateMS) / intervalMS) * limit\n\n-- calculated token balance coming into this transaction\nlocal grossTokens = math.min(prevTokens + addTokens, limit)\n\n-- token balance after trying this transaction\nlocal netTokens = grossTokens - amount\n\n-- time to fill enough to retry this amount\nlocal retryDelta = 0\n\nlocal rejected = false\nlocal forced = false\n\nif netTokens < 0 then -- we used more than we have\n   if force then\n      forced = true\n      netTokens = 0 -- drain the swamp\n   else\n      rejected = true\n      netTokens = grossTokens -- rejection doesn't eat tokens\n   end\n   retryDelta = math.ceil(((amount - netTokens) / limit) * intervalMS)\nelse -- polite transaction\n   local nextNet = netTokens - amount\n   if nextNet < 0 then -- will need to wait to repeat\n      retryDelta = math.ceil((math.abs(nextNet) / limit) * intervalMS)\n   end\nend\n\n-- rejected requests don't cost anything\n-- forced requests show up here as !rejected, but with netTokens = 0 (drained)\nif rejected == false then\n\n   redis.call('PSETEX',key,intervalMS,netTokens)\n   \n   if addTokens > 0 or initialUpdateMS == false then\n      redis.call('PSETEX',timestampKey,intervalMS,nowMS)\n   else\n      redis.call('PEXPIRE',timestampKey,intervalMS)\n   end\nend\n\nreturn { netTokens, rejected, retryDelta, forced }\n","sha1":"509ff8bccbfbcde728dd56616d4033a55da44f34"}